<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Address API Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            line-height: 1.4;
        }
        .log-entry {
            margin: 10px 0;
            padding: 5px;
            background: rgba(0, 255, 0, 0.1);
            border-left: 3px solid #00ff00;
        }
        .timestamp {
            color: #ffff00;
        }
        .error {
            color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            border-left-color: #ff0000;
        }
        .success {
            color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
            border-left-color: #00ff00;
        }
        .data {
            background: #2a2a2a;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            white-space: pre-wrap;
            font-size: 12px;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 10px 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #output {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #00ff00;
            padding: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>üß™ Address API Test Console</h1>
    <p>Testing address parsing and API responses for different input scenarios</p>
    
    <button onclick="runTests()">üöÄ Run All Tests</button>
    <button onclick="testSpecificAddresses()">üéØ Test Specific Addresses</button>
    <button onclick="testCoordinateAccuracy()">üó∫Ô∏è Test Coordinate Accuracy</button>
    <button onclick="clearOutput()">üóëÔ∏è Clear Output</button>
    <button onclick="downloadLog()">üíæ Download Log</button>
    
    <div id="output"></div>

    <script>
        let allLogs = [];
        
        function log(message, data = null, type = 'info') {
            const timestamp = new Date().toISOString();
            const entry = { timestamp, message, data, type };
            allLogs.push(entry);
            
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            
            let html = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            if (data) {
                html += `<div class="data">${JSON.stringify(data, null, 2)}</div>`;
            }
            div.innerHTML = html;
            
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = '';
            allLogs = [];
        }

        function downloadLog() {
            const logText = allLogs.map(entry => {
                let line = `[${entry.timestamp}] ${entry.message}`;
                if (entry.data) {
                    line += '\n' + JSON.stringify(entry.data, null, 2);
                }
                return line;
            }).join('\n\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'address-api-test-log.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Address parsing logic from BasicInfoStep.tsx
        function parseAddressQuery(query) {
            log('üîç PARSING ADDRESS QUERY:', query);
            
            // Handle full address format (comma-separated)
            if (query.includes(',')) {
                const parts = query.split(',').map(part => part.trim());
                log('üìã COMMA-SEPARATED PARTS:', parts);
                
                // First part should contain street address
                const streetPart = parts[0];
                log('üè† STREET PART:', streetPart);
                
                // Extract street number and street name/type from first part
                const streetMatch = streetPart.match(/^(\d+)\s+(.+)$/);
                if (streetMatch) {
                    const streetNumber = streetMatch[1];
                    const streetNameType = streetMatch[2].toUpperCase();
                    log('üìç STREET NUMBER:', streetNumber);
                    log('üìç STREET NAME/TYPE:', streetNameType);
                    
                    // Split street name and type
                    const nameTypeParts = streetNameType.split(' ');
                    if (nameTypeParts.length >= 2) {
                        // Last part is street type, everything else is street name
                        const streetType = nameTypeParts[nameTypeParts.length - 1];
                        const streetName = nameTypeParts.slice(0, -1).join(' ');
                        log('‚úÖ PARSED STREET NAME:', streetName);
                        log('‚úÖ PARSED STREET TYPE:', streetType);
                        
                        return {
                            streetNumber,
                            streetName,
                            streetType,
                            suburb: parts[1] || '',
                            state: parts[2] || '',
                            postcode: parts[3] || ''
                        };
                    } else {
                        // Single word street name, no type
                        log('‚ö†Ô∏è SINGLE WORD STREET NAME:', streetNameType);
                        return {
                            streetNumber,
                            streetName: streetNameType,
                            streetType: '',
                            suburb: parts[1] || '',
                            state: parts[2] || '',
                            postcode: parts[3] || ''
                        };
                    }
                }
            }
            
            // Fallback for simple format
            const parts = query.trim().split(' ');
            const streetNumber = parts[0] && /^\d+/.test(parts[0]) ? parts[0] : '';
            
            const remaining = streetNumber ? parts.slice(1) : parts;
            const streetTypes = ['PL', 'PLACE', 'ST', 'STREET', 'RD', 'ROAD', 'AVE', 'AVENUE', 'DR', 'DRIVE'];
            
            let streetType = '';
            let streetName = '';
            
            if (remaining.length > 0) {
                const lastWord = remaining[remaining.length - 1].toUpperCase();
                log('üîç SIMPLE FORMAT - CHECKING LAST WORD:', lastWord);
                log('üîç SIMPLE FORMAT - AVAILABLE STREET TYPES:', streetTypes);
                
                if (streetTypes.includes(lastWord)) {
                    streetType = lastWord === 'PL' ? 'PLACE' : lastWord;
                    streetName = remaining.slice(0, -1).join(' ').toUpperCase();
                    log('‚úÖ SIMPLE FORMAT - FOUND STREET TYPE:', streetType);
                    log('‚úÖ SIMPLE FORMAT - EXTRACTED STREET NAME:', streetName);
                } else {
                    streetName = remaining.join(' ').toUpperCase();
                    log('‚ö†Ô∏è SIMPLE FORMAT - NO STREET TYPE FOUND, USING FULL NAME:', streetName);
                }
            }
            
            return { streetNumber, streetName, streetType };
        }

        // Generate mock Geoscape responses with intelligent filtering
        function generateMockResponses(query) {
            log(`\n=== PROCESSING QUERY: "${query}" ===`);
            
            const parsed = parseAddressQuery(query);
            log('üìã Parsed Address Components:', parsed);

            if (!query.toLowerCase().includes('milburn') && 
                !query.toLowerCase().includes('milbirn') && 
                !query.toLowerCase().includes('mileurn')) {
                log('üîç Generated 0 mock responses:', []);
                return [];
            }

            // Detect location context from query
            const queryLower = query.toLowerCase();
            const hasSuburbContext = queryLower.includes('st ives') || queryLower.includes('chase');
            const hasStateContext = queryLower.includes('nsw') || queryLower.includes('vic') || queryLower.includes('tas');
            const hasPostcodeContext = queryLower.includes('2075') || queryLower.includes('3064') || queryLower.includes('7010');
            
            log('üéØ LOCATION CONTEXT DETECTION:', {
                hasSuburbContext,
                hasStateContext, 
                hasPostcodeContext,
                shouldFilter: hasSuburbContext || hasStateContext || hasPostcodeContext
            });

            // All possible addresses
            const allAddresses = [
                {
                    address: `${parsed.streetNumber || '4'} MILBURN PLACE, CRAIGIEBURN VIC 3064`,
                    id: "G4VIC4242188",
                    data: {
                        streetNumber: parsed.streetNumber || '4',
                        streetName: 'MILBURN',
                        streetType: 'PLACE',
                        suburb: 'CRAIGIEBURN',
                        state: 'VIC',
                        postcode: '3064',
                        latitude: -37.5850,
                        longitude: 144.9400,
                        propertyType: 'Residential',
                        confidenceScore: 0.95
                    },
                    matchScore: 0.95
                },
                {
                    address: `${parsed.streetNumber || '4'} MILBURN PLACE, ST IVES CHASE NSW 2075`,
                    id: parsed.streetNumber === '14' ? "GNSW2075191" : "GNSW2075190",
                    data: {
                        streetNumber: parsed.streetNumber || '4',
                        streetName: 'MILBURN',
                        streetType: 'PLACE',
                        suburb: 'ST IVES CHASE',
                        state: 'NSW',
                        postcode: '2075',
                        latitude: parsed.streetNumber === '14' ? -33.7020 : -33.7019,
                        longitude: parsed.streetNumber === '14' ? 151.1678 : 151.1677,
                        propertyType: 'Residential',
                        confidenceScore: 0.98
                    },
                    matchScore: 0.98
                }
            ];

            // Smart filtering based on context
            let filteredAddresses = allAddresses;

            if (hasSuburbContext || hasStateContext || hasPostcodeContext) {
                log('üîç APPLYING INTELLIGENT FILTERING...');
                
                filteredAddresses = allAddresses.filter(addr => {
                    let matches = false;
                    
                    // Check suburb match
                    if (hasSuburbContext) {
                        const suburbMatch = queryLower.includes('st ives') && addr.data.suburb.toLowerCase().includes('st ives');
                        matches = matches || suburbMatch;
                        log(`   ${addr.data.suburb}: suburb match = ${suburbMatch}`);
                    }
                    
                    // Check state match  
                    if (hasStateContext) {
                        const stateMatch = (queryLower.includes('nsw') && addr.data.state === 'NSW') ||
                                          (queryLower.includes('vic') && addr.data.state === 'VIC') ||
                                          (queryLower.includes('tas') && addr.data.state === 'TAS');
                        matches = matches || stateMatch;
                        log(`   ${addr.data.state}: state match = ${stateMatch}`);
                    }
                    
                    // Check postcode match
                    if (hasPostcodeContext) {
                        const postcodeMatch = queryLower.includes(addr.data.postcode.toLowerCase());
                        matches = matches || postcodeMatch;
                        log(`   ${addr.data.postcode}: postcode match = ${postcodeMatch}`);
                    }
                    
                    // If no context provided, show all (early typing)
                    if (!hasSuburbContext && !hasStateContext && !hasPostcodeContext) {
                        matches = true;
                    }
                    
                    log(`   üéØ ${addr.data.suburb} ${addr.data.state}: final match = ${matches}`);
                    return matches;
                });
                
                log(`üìä FILTERED: ${allAddresses.length} ‚Üí ${filteredAddresses.length} addresses`);
            }

            // Sort by match score (highest first)
            filteredAddresses.sort((a, b) => b.matchScore - a.matchScore);

            // Convert to expected format
            const responses = filteredAddresses.map(addr => ({
                address: addr.address,
                id: addr.id,
                data: addr.data
            }));

            log(`üîç Generated ${responses.length} filtered responses:`, responses);
            return responses;
        }

        // Test different typing scenarios
        async function runTypingTests() {
            log('\nüöÄ STARTING ADDRESS API TYPING TESTS\n', null, 'success');

            const testScenarios = [
                { query: '4 M', description: 'Start typing - too short' },
                { query: '4 Mi', description: 'Continue typing - still too short' },
                { query: '4 Mil', description: 'Minimum length reached ‚úì' },
                { query: '4 Milb', description: 'Building the word' },
                { query: '4 Milbu', description: 'Almost there' },
                { query: '4 Milbur', description: 'Getting closer' },
                { query: '4 Milburn', description: 'Complete street name ‚úì' },
                { query: '4 Milburn P', description: 'Starting street type' },
                { query: '4 Milburn Pl', description: 'Short street type ‚úì' },
                { query: '4 Milburn Place', description: 'Complete address ‚úì' },
                { query: '4 Milburn Place, St', description: 'Adding suburb' },
                { query: '4 Milburn Place, St Ives', description: 'Building suburb' },
                { query: '4 Milburn Place, St Ives Chase', description: 'Complete suburb ‚úì' },
                { query: '4 Milburn Place, St Ives Chase, NSW', description: 'Adding state' },
                { query: '4 Milburn Place, St Ives Chase, NSW, 2075', description: 'Complete address with postcode ‚úì' },
                
                // Test misspellings as requested
                { query: '4 Milbirn', description: '‚ùå Misspelling: u -> i' },
                { query: '4 Mileurn', description: '‚ùå Misspelling: b -> e' },
                { query: '4 Milburn', description: '‚úÖ Corrected spelling' },
                
                // Test different number as requested
                { query: '14 Milburn', description: 'üè† Different street number' },
                { query: '14 Milburn Place', description: 'üè† Different number complete ‚úì' },
            ];

            for (const scenario of testScenarios) {
                log(`\n--- TEST: ${scenario.description} ---`);
                log(`üìù Input Query: "${scenario.query}"`);
                
                if (scenario.query.length < 3) {
                    log('‚ùå Query too short - no search performed', null, 'error');
                    continue;
                }

                const responses = generateMockResponses(scenario.query);
                
                if (responses.length > 0) {
                    const selected = responses[0];
                    log(`‚úÖ Would auto-populate with:`, {
                        streetNumber: selected.data.streetNumber,
                        streetName: selected.data.streetName,
                        streetType: selected.data.streetType,
                        suburb: selected.data.suburb,
                        state: selected.data.state,
                        postcode: selected.data.postcode,
                        propertyId: selected.id,
                        coordinates: `${selected.data.latitude}, ${selected.data.longitude}`,
                        confidence: selected.data.confidenceScore
                    }, 'success');

                    if (selected.data.streetType) {
                        log(`‚úÖ Street Type would be set to: "${selected.data.streetType}"`, null, 'success');
                    } else {
                        log(`‚ùå Street Type would be EMPTY!`, null, 'error');
                    }

                    // Test the setValue simulation
                    log('üîß Simulating form field population:');
                    log(`setValue('address.streetNumber', '${selected.data.streetNumber}')`);
                    log(`setValue('address.streetName', '${selected.data.streetName}')`);
                    log(`setValue('address.streetType', '${selected.data.streetType}') ‚¨ÖÔ∏è KEY FIELD`);
                    log(`setValue('address.suburb', '${selected.data.suburb}')`);
                    log(`setValue('address.state', '${selected.data.state}')`);
                    log(`setValue('address.postcode', '${selected.data.postcode}')`);
                    log(`setValue('address.propertyId', '${selected.id}')`);
                } else {
                    log('‚ùå No responses generated', null, 'error');
                }

                // Add a small delay to simulate real typing
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // Test property ID differences
        function testPropertyIds() {
            log('\nüè† TESTING PROPERTY ID VARIATIONS\n', null, 'success');
            
            const addresses = [
                '4 Milburn Place',
                '14 Milburn Place'
            ];

            addresses.forEach(addr => {
                const responses = generateMockResponses(addr);
                if (responses.length > 0) {
                    const selected = responses.find(r => r.data.suburb === 'ST IVES CHASE');
                    if (selected) {
                        log(`üìç ${addr} -> Property ID: ${selected.id}`, {
                            streetNumber: selected.data.streetNumber,
                            coordinates: `${selected.data.latitude}, ${selected.data.longitude}`,
                            propertyId: selected.id
                        });
                    }
                }
            });
        }

        // Enhanced test for specific address parsing issues
        function testSpecificAddresses() {
            log('\nüéØ TESTING SPECIFIC ADDRESS PARSING ISSUES\n', null, 'success');
            
            const testAddresses = [
                '4 Milburn Place, St Ives Chase NSW 2075',
                '14 Milburn Place, St Ives Chase NSW 2075'
            ];
            
            testAddresses.forEach(addr => {
                log(`\n--- TESTING: "${addr}" ---`);
                
                // Test parsing logic
                const parsed = parseAddressQuery(addr);
                log('üìã PARSED COMPONENTS:', parsed);
                
                // Test mock API response
                const responses = generateMockResponses(addr);
                if (responses.length > 0) {
                    const selected = responses[0];
                    log('üéØ MOCK API RESPONSE:', {
                        address: selected.address,
                        propertyId: selected.id,
                        streetNumber: selected.data.streetNumber,
                        streetName: selected.data.streetName,
                        streetType: selected.data.streetType,
                        coordinates: `${selected.data.latitude}, ${selected.data.longitude}`,
                        suburb: selected.data.suburb,
                        state: selected.data.state,
                        postcode: selected.data.postcode
                    });
                    
                    // Test form field population simulation
                    log('üîß FORM FIELD POPULATION SIMULATION:');
                    log(`setValue('address.streetNumber', '${selected.data.streetNumber}')`);
                    log(`setValue('address.streetName', '${selected.data.streetName}')`);
                    log(`setValue('address.streetType', '${selected.data.streetType}') ‚¨ÖÔ∏è CRITICAL FIELD`);
                    log(`setValue('address.suburb', '${selected.data.suburb}')`);
                    log(`setValue('address.state', '${selected.data.state}')`);
                    log(`setValue('address.postcode', '${selected.data.postcode}')`);
                    log(`setValue('address.latitude', ${selected.data.latitude})`);
                    log(`setValue('address.longitude', ${selected.data.longitude})`);
                    log(`setValue('address.propertyId', '${selected.id}')`);
                    
                    // Check for issues
                    if (!selected.data.streetType) {
                        log('‚ùå ISSUE: streetType is empty!', null, 'error');
                    } else {
                        log(`‚úÖ streetType populated: "${selected.data.streetType}"`, null, 'success');
                    }
                    
                    if (selected.data.streetName.includes('PLACE')) {
                        log('‚ùå ISSUE: streetName contains "PLACE" - should be separated!', null, 'error');
                    } else {
                        log(`‚úÖ streetName correctly parsed: "${selected.data.streetName}"`, null, 'success');
                    }
                }
            });
        }

        // Test coordinate accuracy
        function testCoordinateAccuracy() {
            log('\nüó∫Ô∏è TESTING COORDINATE ACCURACY\n', null, 'success');
            
            const             coordinates = [
                { address: '4 Milburn Place', lat: -33.7019, lng: 151.1677, id: 'GNSW2075190' },
                { address: '14 Milburn Place', lat: -33.7020, lng: 151.1678, id: 'GNSW2075191' }
            ];
            
            coordinates.forEach(coord => {
                log(`üìç ${coord.address}:`, {
                    latitude: coord.lat,
                    longitude: coord.lng,
                    propertyId: coord.id,
                    note: 'These coordinates may be incorrect for actual Milburn Place location'
                });
            });
            
            log('\n‚ö†Ô∏è COORDINATE ISSUE:', {
                problem: 'Mock coordinates are not accurate for actual Milburn Place, St Ives Chase',
                solution: 'Need real Geoscape API coordinates or better mock data',
                impact: 'Map pins show wrong locations'
            }, 'error');
        }

        // Main test runner
        async function runTests() {
            clearOutput();
            log('üß™ ENHANCED ADDRESS API BEHAVIOR TEST STARTING', null, 'success');
            log('=' * 60);
            
            await runTypingTests();
            testPropertyIds();
            testSpecificAddresses();
            testCoordinateAccuracy();
            
            log('\nüìä ENHANCED TEST SUMMARY', null, 'success');
            log('=' * 40);
            log('‚úÖ Address parsing logic works correctly');
            log('‚úÖ Street Type should populate as "PLACE"');
            log('‚úÖ Different property IDs for different addresses');
            log('‚úÖ Form setValue calls should work');
            log('\nüîç CRITICAL ISSUES FOUND:');
            log('1. Street Name field contains full address instead of just street name');
            log('2. Street Type field not being populated correctly');
            log('3. Map coordinates are inaccurate for actual locations');
            log('4. Need to fix parsing logic in BasicInfoStep component');
            log('\nüõ†Ô∏è NEXT STEPS:');
            log('1. Fix address parsing in BasicInfoStep.tsx');
            log('2. Update mock coordinates to be more realistic');
            log('3. Test with real Geoscape API coordinates');
            log('4. Verify form field population is working');
            
            log('\n‚úÖ ENHANCED TEST COMPLETED - Check log for detailed analysis', null, 'success');
        }
    </script>
</body>
</html>